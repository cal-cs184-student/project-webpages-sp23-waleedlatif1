<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=-lTUqgJg2dxbe4D7B5DEIA3jn2WilaVUapNOYl4762s');.lst-kix_q5hwdhomypan-2>li:before{content:"\0025a0  "}ul.lst-kix_q5hwdhomypan-2{list-style-type:none}ul.lst-kix_q5hwdhomypan-3{list-style-type:none}ul.lst-kix_q5hwdhomypan-0{list-style-type:none}.lst-kix_q5hwdhomypan-1>li:before{content:"\0025cb  "}.lst-kix_q5hwdhomypan-3>li:before{content:"\0025cf  "}ul.lst-kix_q5hwdhomypan-1{list-style-type:none}ul.lst-kix_q5hwdhomypan-6{list-style-type:none}ul.lst-kix_q5hwdhomypan-7{list-style-type:none}ul.lst-kix_q5hwdhomypan-4{list-style-type:none}ul.lst-kix_q5hwdhomypan-5{list-style-type:none}.lst-kix_q5hwdhomypan-7>li:before{content:"\0025cb  "}.lst-kix_q5hwdhomypan-0>li:before{content:"\0025cf  "}.lst-kix_q5hwdhomypan-8>li:before{content:"\0025a0  "}ul.lst-kix_ovh8vqa8bzd9-0{list-style-type:none}ul.lst-kix_ovh8vqa8bzd9-1{list-style-type:none}.lst-kix_ovh8vqa8bzd9-2>li:before{content:"\0025a0  "}ul.lst-kix_ovh8vqa8bzd9-2{list-style-type:none}ul.lst-kix_ovh8vqa8bzd9-3{list-style-type:none}.lst-kix_q5hwdhomypan-6>li:before{content:"\0025cf  "}ul.lst-kix_ovh8vqa8bzd9-4{list-style-type:none}ul.lst-kix_ovh8vqa8bzd9-5{list-style-type:none}.lst-kix_q5hwdhomypan-5>li:before{content:"\0025a0  "}.lst-kix_ovh8vqa8bzd9-1>li:before{content:"\0025cb  "}ul.lst-kix_ovh8vqa8bzd9-6{list-style-type:none}ul.lst-kix_ovh8vqa8bzd9-7{list-style-type:none}.lst-kix_q5hwdhomypan-4>li:before{content:"\0025cb  "}ul.lst-kix_ovh8vqa8bzd9-8{list-style-type:none}.lst-kix_ovh8vqa8bzd9-0>li:before{content:"\0025cf  "}.lst-kix_ovh8vqa8bzd9-5>li:before{content:"\0025a0  "}.lst-kix_ovh8vqa8bzd9-7>li:before{content:"\0025cb  "}.lst-kix_ovh8vqa8bzd9-6>li:before{content:"\0025cf  "}.lst-kix_ovh8vqa8bzd9-3>li:before{content:"\0025cf  "}.lst-kix_ovh8vqa8bzd9-4>li:before{content:"\0025cb  "}ul.lst-kix_q5hwdhomypan-8{list-style-type:none}.lst-kix_ovh8vqa8bzd9-8>li:before{content:"\0025a0  "}ol{margin:0;padding:0}table td,table th{padding:0}.c1{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Montserrat";font-style:normal}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Montserrat";font-style:normal}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c9{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c8{font-weight:400;font-family:"Montserrat"}.c6{font-weight:700;font-family:"Montserrat"}.c5{text-indent:36pt}.c7{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c9 doc-content"><p class="c4"><span class="c3">CS184 Spring 2023 Assignment 2: Geometric Modeling</span></p><p class="c4"><span class="c3">by Kareem Koujah and Waleed Latif</span></p><p class="c4 c7"><span class="c3"></span></p><p class="c2"><span class="c1">Overview:</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">In this assignment, we explore different topics surrounding geometric modeling that we were introduced to in class. We begin by building bezier curves using the de Casteljau algorithm, manipulate triangle meshes represented by using the half-edge data structure, and implementing loop subdivision for mesh upsampling. </span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">At the beginning, we are tasked with implementing single iterations of the bezier curve computation by using de Casteljau. We lerp each pair of points to compute the intermediate points used to finally compute the bezier curve. Then, we are tasked with calculating a vertex normal by using the half-edge data structure. We are given how to &nbsp;compute a normal for a face, so we reduced the problem to iterating over the amount of faces connected to that vertex, and calculating the normal for those associated faces and taking a weighted average to finally get the vertex normal. </span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">In the next tasks, we implement local remeshing operations. Though we had done this mechanically in discussion, implementing it in code was a difficult taks because it required us to familiarize ourselves with the halfedge data structure and manipulate pointers. Through these tasks, we learned to be patient and diligent when reassigning pointers and make sure that we really understood the underlying remeshing operation, whether it was an edge split or edge flip.</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">Prior to working on this assignment, we knew on a high level what these individual concepts meant and what they were used for based on what we have learned about them in discussion and lecture, but after doing the assignment we have gained a new understanding of the application of these concepts, and how they are used to influence geometric modeling.</span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c6">Task 1: </span><span class="c1">&nbsp;Bezier Curves with 1D de Casteljau Subdivision</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">In this task, we had to implement de Casteljau&rsquo;s algorithm to evaluate Bezier curves. The algorithm relies on recursive subdivision and successive linear interpolation to evaluate a bezier curve. As you can see in the images below, we recursively lerp on each edge, and evaluate the bezier curve based on the edges. </span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c8">The way that we implemented this algorithm was by filling in the 2D case for evaluating a single step of the de Casteljau algorithm in evaluteStep. For the subdivision, we go over the list of control points and use the lerp equation with the given parameter t to evaluate the next point in the subdivision. </span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 376.00px;"><img alt="" src="images/image10.png" style="width: 624.00px; height: 376.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 389.50px; height: 360.47px;"><img alt="" src="images/image3.png" style="width: 389.50px; height: 360.47px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c6">Task 2: </span><span class="c1">Bezier Surfaces with Separable 1D de Casteljau</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">In task 2, we have to extend the concept of the de Casteljau algorithm from just bezier curves to bezier surfaces. One method of doing this, the one we implement here, is the separable 1D de Casteljau algorithm. To do this, we parameterize the output by points (u, v). Our eventual goal is to evaluate the surface position corresponding to (u, v) and in order to do this, we use de Casteljau to evaluate the point u on each of the bezier curves that we create in u. Then, after we have the moving curve, we use the 1D de Casteljau case (similar to t1) to evaluate the point v on the moving curve. </span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">To implement this, we extend the evaluateStep function to handle subdivision in the 3D case which is identical to the way we did it in t1, except now we output a 3D vector for the next point in subdivision. In evaluate1D, we actually get the control points by calling the evaluateStep function implemented earlier. Doing so, we are able to extract the final interpolated vector. Now for the method that we are doing, we take the final vector and parameterize by the scalar interpolation parameter u to get the moving curves, and finally call evaluate1D to evaluate the other scalar interpolation parameter v.</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 414.67px;"><img alt="" src="images/image9.png" style="width: 624.00px; height: 414.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c6">Task 3: </span><span class="c1">Area-Weighted Vertex Normals</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">For task 3, we have to take area-weighted vertex normals for the vertices. To return a unit normal at the given vertex, we had to take an area-weighted average of the normals for neighboring triangles and normalize it. Because Face::normal() was implemented for us, we wanted to use that in our implementation.</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">We begin by marking the halfedge(s) for the vertex of interest, and it didn&rsquo;t matter which one we began with because we looped over the triangle until we returned to that halfedge. Then, we check to see if the face of the halfedge of the vertex is not a boundary to ensure that we don&rsquo;t add the area if it is otherwise we would get stuck in a boundary loop. Once we confirm that it is not a boundary, we calculate the two vectors and take their cross product to give us the vertex normal to the surface. </span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">By looping over every triangle and finding the associated normal in those triangles, then taking the area-weighted average, we are able to finally get the unit normal at our desired vertex.</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 570.50px; height: 350.16px;"><img alt="" src="images/image4.png" style="width: 570.50px; height: 350.16px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c6">Task 4: </span><span class="c1">Edge Flip</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">As I was implementing the flipEdge function, I knew that it was a very intricate process that required a very well-planned process. I visualized and understood all the elements required to flip and what pointers needed to be manipulated in the process. First, you must check if it is a boundary, if it is then you return it immediately, if not you can continue. Then you have to instatiate every element in the mesh in order to manipulate it later, so using the iterators, I iterated through each element(halfedges, edges, vertices, and faces) and stored them in variables. Then I manipulated the pointers of each element and then returned the edge iterator. My debugging process wasn&rsquo;t long as I was very careful with the implementation as I carefully laid out all the pointers and where they should go. </span></p><p class="c2"><span class="c3">Flipped some edges in the middle &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No flipped edges</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 357.89px; height: 233.00px;"><img alt="" src="images/image12.png" style="width: 357.89px; height: 233.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 389.50px; height: 226.58px;"><img alt="" src="images/image1.png" style="width: 389.50px; height: 226.58px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c6">Task 5: </span><span class="c1">Edge Split </span></p><p class="c2"><span class="c3">The split function was implemented a similar way to how the flip function was implemented, except we had to add new elements since we are adding an edge visually. We had to add a new vertex, three new edges, and six new halfedges to the mesh. &nbsp;I made sure to update the isNew field for all new elements as it was in the halfEdgeMesh.h file&rsquo;s comments saying it was needed for subdivision. I encountered a bug that took me a really long time and it was as simple as mixing up the pointers from copy and pasting from the previous function. I had to go through each line and it was hard to keep track of all the variables so I decided to draw everything out with a very detailed picture of all the elements that was involved and use the debugging methods. I ended up finding the bug after a very draining process (learned my lesson to be careful when copy and pasting and to write it from scratch even if it maybe similar because what I thought would save me time costed me a lot of time).</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 337.50px; height: 219.66px;"><img alt="" src="images/image12.png" style="width: 337.50px; height: 219.66px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 338.00px; height: 218.59px;"><img alt="" src="images/image7.png" style="width: 338.00px; height: 218.59px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c2 c5"><span class="c3">No flipped edges&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Some edges are split </span></p><p class="c2 c5"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 330.00px; height: 186.67px;"><img alt="" src="images/image2.png" style="width: 330.00px; height: 186.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c8">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c2"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c2 c5"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Some edges are flipped then split</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c6">Task 6: </span><span class="c1">Loop Subdivision for Mesh Upsampling</span></p><p class="c2"><span class="c3">I implemented loop subdivision by following each step very carefully. In the first step I computed the new positions for all the vertices in the input mesh and stored them in the new position by looping through the entire mesh. Then I computed the updated vertex positions associated with the edges previously and stored that in new position by looping through every vertex and in each vertex I looped through the halfedges. Then the important part, I split each edge of the original mesh. At first I did not do that and my code was crashing and then I read the comment more carefully and realized that it had to be the original mesh, so I grabbed the size of the mesh using nEdges() and looped that many times and only updated if the edge wasn&rsquo;t new. Then we had to flip the new edge that connect to old and new vertex, so I looped through each edge and had a condition that made sure that combination was met and flipped the proper edges. Finally, I copied each vertex in the newposition to the actual position and set their isNew bool to false. </span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">As you can see through loop subdivision, it makes sharper edges more round. Loop subdivision makes the shape more smooth, which in return gives sharper edges are more round loop. The more you subdivide the rounder the object gets as you can see with the cube. The cube slowly becomes more sphere-like the more you loop subdivide. Since it adds more vertices then the mesh becomes less visible, which allows for more faces and those faces look more cohesive the less they are noticeable. If you pre split the edges before applying the subdivision then it reduces the effect of loop subdivision on sharp corners. The additional edges can help to maintain the sharpness of the corners and edges even after the subdivision is applied. Pre-splitting can also increase the number of vertices and potentially introducing new topology issues. </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 193.97px; height: 161.50px;"><img alt="" src="images/image11.png" style="width: 193.97px; height: 161.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 172.15px; height: 136.50px;"><img alt="" src="images/image8.png" style="width: 172.15px; height: 136.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 199.30px; height: 146.00px;"><img alt="" src="images/image6.png" style="width: 199.30px; height: 146.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 156.50px; height: 131.26px;"><img alt="" src="images/image5.png" style="width: 156.50px; height: 131.26px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">Cube 1x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cube 4x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cube 16x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cube 64x</span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p></body></html>